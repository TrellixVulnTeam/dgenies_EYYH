#!/usr/bin/env python3

"""Prepare PAF file

Short desc: Prepare the PAF file from minimap output to be loaded by the program
Details: change coordinates of matches to be bounded one to another

Usage:
    prepare_paf.py -i IN -q FASTA1 -t FASTA2 -o OUT [-r NAME1] [-u NAME2]
    prepare_paf.py -v | --version

Options:
    -i --input=IN  Input PAF file generated by minimap
    -q --query=FASTA1    Query fasta file compared with minimap
    -t --target=FASTA2    Target fasta file compared with minimap
    -r --query-name=NAME1   Query name
    -u --target-name=NAME2  Target name
    -o --output=OUT Output PAF file
    -h --help   Show this screen
    -v --version    Show version
"""

__NAME__ = "PreparePAF"
__VERSION__ = 0.1

import os
from docopt import docopt
from collections import OrderedDict


class Fasta:
    def __init__(self, fasta, name=None):
        self.fasta = fasta
        self.fai = fasta + ".fai"
        self.name = os.path.splitext(os.path.basename(fasta))[0] if name is None else name
        self.contigs = OrderedDict()
        self.total_length = 0
        self.__load()

    def __load(self):
        start = 0
        with open(self.fai, "r") as fai_file:
            for line in fai_file:
                parts = line.strip("\n").split("\t")
                length = int(parts[1])
                self.contigs[parts[0]] = {
                    "length": length,
                    "start": start
                }
                start += length
                self.total_length += length

    def get_contig(self, contig):
        return self.contigs[contig]

    def build_index(self, filename):
        with open(filename, "w") as idx:
            for contig, props in self.contigs.items():
                idx.write(contig + "\t" + str(props["length"]) + "\n")


def build_new_paf_file(paf_in: str, paf_out: str, query: Fasta, target: Fasta):
    with open(paf_in, "r") as paf:
        with open(paf_out, "w") as paf_o:
            for line in paf:
                parts = line.strip("\n").split("\t")
                q_name = parts[0]
                q_start = query.get_contig(q_name)["start"]
                parts[0] = query.name  # Change query name
                parts[1] = str(query.total_length)  # Change length of query
                parts[2] = str(int(parts[2]) + q_start)  # Change start of query
                parts[3] = str(int(parts[3]) + q_start)  # Change end of query
                t_name = parts[5]
                parts[5] = target.name  # Change target name
                t_start = target.get_contig(t_name)["start"]
                parts[6] = str(target.total_length)  # Change length of query
                parts[7] = str(int(parts[7]) + t_start)  # Change start for target
                parts[8] = str(int(parts[8]) + t_start)  # Change end for target
                paf_o.write("\t".join(parts) + "\n")


if __name__ == '__main__':
    args = docopt(__doc__)
    if args["--version"]:
        print(__NAME__, __VERSION__)
    else:
        if not os.path.exists(args["--query"] + ".fai"):
            raise Exception("Fasta file %s is not indexed!" % args["--query"])
        if not os.path.exists(args["--target"] + ".fai"):
            raise Exception("Fasta file %s is not indexed!" % args["--target"])
        query = Fasta(args["--query"], args["--query-name"])
        target = Fasta(args["--target"], args["--target-name"])
        build_new_paf_file(args["--input"], args["--output"], query, target)
        basedir = os.path.dirname(args["--output"])
        i = 0
        for fasta in [query, target]:
            idx_file = os.path.join(basedir, "query.idx" if i==0 else "target.idx")
            fasta.build_index(idx_file)
            i += 1
